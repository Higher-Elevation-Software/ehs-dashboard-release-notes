name: Aggregate release note (on repository_dispatch)

on:
  repository_dispatch:
    types: [release-note]

env:
  TARGET_BRANCH: ${{ github.event.repository.default_branch }}
  TARGET_BRANCH_OVERRIDE: ${{ github.event.client_payload.target_branch }}

permissions:
  contents: write

jobs:
  add-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Validate, Parse, and Enhance with Gemini
        id: parse
        env:
          GH_TOKEN: ${{ secrets.REPO_READER_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -euo pipefail
          export GH_TOKEN="${{ secrets.REPO_READER_TOKEN }}"
          
          # Install dependencies
          pip install google-generativeai requests pyyaml

          event="$GITHUB_EVENT_PATH"
          component=$(jq -r '.client_payload.component // ""' "$event")
          sha=$(jq -r '.client_payload.sha // ""' "$event")
          title=$(jq -r '.client_payload.title // ""' "$event")
          summary=$(jq -r '.client_payload.summary // ""' "$event")
          pr=$(jq -r '.client_payload.pr // ""' "$event")
          deploy_time=$(jq -r '.client_payload.deploy_time // ""' "$event")
          environment=$(jq -r '.client_payload.environment // ""' "$event")
          target_branch=$(jq -r '.client_payload.target_branch // ""' "$event")

          if [ -z "$component" ] || [ -z "$sha" ] || [ -z "$title" ]; then
            echo "Missing required fields: component, sha, and title are required" >&2
            exit 1
          fi

          # Defaults
          [ -z "$summary" ] && summary="$title"
          [ -z "$deploy_time" ] && deploy_time=$(date -u +%Y%m%dT%H%M%SZ)
          [ -z "$environment" ] && environment="production"
          [ -z "$target_branch" ] && target_branch="${TARGET_BRANCH_OVERRIDE:-}"
          [ -z "$target_branch" ] && target_branch="$TARGET_BRANCH"

          # Fetch PR Context
          repo_name="Higher-Elevation-Software/$component"
          pr_title=""
          pr_body=""

          echo "Attempting to fetch PR details for $repo_name..."
          if [ -n "$pr" ] && [ "$pr" != "null" ]; then
             echo "Fetching PR #$pr..."
             # Fetch PR JSON or return ERROR on failure
             json=$(gh pr view "$pr" -R "$repo_name" --json title,body 2>&1 || echo "ERROR")
             
             # Check if gh command succeeded
             if [[ "$json" == "ERROR" ]] || [[ "$json" == *"graphql error"* ]] || [[ "$json" == *"Could not resolve to a PullRequest"* ]]; then
                echo "Failed to fetch PR #$pr via gh CLI."
                echo "Error output: $json"
             else
                # Parse JSON safely
                pr_title=$(echo "$json" | jq -r .title 2>/dev/null || echo "")
                pr_body=$(echo "$json" | jq -r .body 2>/dev/null || echo "")
                
                if [ -n "$pr_title" ]; then
                    echo "Found PR #$pr details."
                else
                    echo "Failed to parse JSON for PR #$pr."
                    echo "Raw output: $json"
                fi
             fi
          elif [ -n "$sha" ]; then
             echo "Searching for PR associated with SHA $sha..."
             # Try to find PR by SHA
             json=$(gh pr list -R "$repo_name" --search "$sha" --state merged --json number,title,body --limit 1 2>&1 | jq '.[0] // empty' || echo "ERROR")
              if [[ "$json" != "ERROR" ]] && [ -n "$json" ]; then
                pr_title=$(echo "$json" | jq -r .title)
                pr_body=$(echo "$json" | jq -r .body)
                pr=$(echo "$json" | jq -r .number)
                echo "Found PR #$pr via SHA."
             else
                echo "No PR found for SHA $sha or error occurred."
                if [[ "$json" == "ERROR" ]]; then echo "Error details: $(gh pr list -R "$repo_name" --search "$sha" --state merged --json number,title,body --limit 1 2>&1)"; fi
             fi
          fi

          short_sha=${sha:0:7}
          safe_component=$(echo "$component" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]-' '-')
          fname="releases/${deploy_time}_${safe_component}_${short_sha}.md"

          mkdir -p releases

          # Export variables for Python
          export component
          export sha
          export title
          export summary
          export pr
          export deploy_time
          export environment
          export target_branch
          export fname
          export pr_title
          export pr_body

          python3 - <<'PY'
          import os
          import re
          import yaml
          import google.generativeai as genai
          from textwrap import dedent
          from datetime import datetime

          component = os.environ["component"]
          sha = os.environ["sha"]
          title = os.environ["title"]
          summary = os.environ["summary"]
          pr = os.environ["pr"]
          deploy_time = os.environ["deploy_time"]
          environment = os.environ["environment"]
          
          pr_title = os.environ.get("pr_title", "")
          pr_body = os.environ.get("pr_body", "")
          gemini_api_key = os.environ.get("GEMINI_API_KEY", "")

          # 1. Extract Issue ID (HES-XXX)
          issue_id = ""
          hes_match = re.search(r"(hes-\d+)", title + " " + pr_title + " " + pr_body, re.IGNORECASE)
          if hes_match:
              issue_id = hes_match.group(1).upper()

          # 2. Determine File Path & Mode
          # If we have an Issue ID, we look for a Feature File. Otherwise, generic timestamp file.
          is_feature_mode = bool(issue_id)
          
          if is_feature_mode:
              fname = f"releases/ISSUE_{issue_id}.md"
          else:
              short_sha = sha[:7]
              safe_component = re.sub(r'[^a-zA-Z0-9-]', '-', component.lower())
              fname = f"releases/{deploy_time}_{safe_component}_{short_sha}.md"
          
          # Export fname for later steps
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"fname={fname}\n")

          # 3. Load Existing Data (If updating)
          existing_content = ""
          existing_frontmatter = {}
          deployments = []
          
          if os.path.exists(fname):
              print(f"Found existing release note for {issue_id}. Merging...")
              with open(fname, 'r') as f:
                  raw_content = f.read()
                  
              # Split YAML Frontmatter
              if raw_content.startswith("---"):
                  try:
                      _, fm_text, body = raw_content.split("---", 2)
                      existing_frontmatter = yaml.safe_load(fm_text)
                      existing_content = body.strip()
                      deployments = existing_frontmatter.get('deployments', [])
                  except Exception as e:
                      print(f"Error parsing existing frontmatter: {e}")
          
          # Add current deployment to list
          current_deployment = {
              'component': component,
              'sha': sha,
              'deploy_time': deploy_time,
              'pr': pr,
              'environment': environment
          }
          deployments.append(current_deployment)

          # 4. Prepare Gemini Inputs
          final_summary = summary
          final_title = title
          category = "Update"
          user_facing = "true"
          
          # Determine Prompt Type (Create vs Merge)
          if gemini_api_key and (pr_title or pr_body):
              try:
                  genai.configure(api_key=gemini_api_key)
                  model = genai.GenerativeModel('gemini-2.5-flash')
                  
                  if existing_content:
                      # MERGE PROMPT
                      prompt = f"""
                      You are an expert Product Marketing Manager for a high-trust EHS Compliance platform.
                      
                      TASK: Update an existing release note to include a new component deployment.
                      The goal is to have a SINGLE cohesive story for the feature "{issue_id}", covering all affected components.
                      
                      EXISTING NOTE:
                      {existing_content}
                      
                      NEW UPDATE ({component}):
                      PR Title: {pr_title}
                      PR Description: {pr_body}
                      
                      INSTRUCTIONS:
                      1. Rewrite the Title and Summary to encompass both the old context and the new update.
                      2. If the new update is just "backend support" for the existing UI feature (or vice versa), merge them into one seamless narrative.
                      3. Maintain the "Zero-Panic" Tone (No "Fix", "Bug", "Error").
                      4. Keep the Category/User Facing flags accurate for the *combined* feature.
                      
                      OUTPUT FORMAT (STRICT):
                      Title: <Merged Title>
                      Category: <Category>
                      User Facing: <true/false>
                      Summary: <Merged Summary>
                      """
                  else:
                      # CREATE PROMPT (Standard)
                      prompt = f"""
                      You are an expert Product Marketing Manager for a high-trust Enterprise EHS Compliance platform.
                      
                      TASK: Transform technical inputs into a customer-facing release note.
                      
                      Inputs:
                      - Component: {component}
                      - PR Title: {pr_title}
                      - PR Description: {pr_body}
                      
                      INSTRUCTIONS:
                      1. Generate a concise, value-driven Title (5-8 words).
                      2. Summarize the changes in 1-2 professional sentences (up to 8 for major features).
                      3. **TONE:** Professional, Reassuring. NEVER imply past failures ("fix", "bug", "wrong" are forbidden). Use "Enhanced", "Refined", "Optimized".
                      4. **Abstraction:** Do NOT mention file paths, class names, or specific variables. Describe the business logic/concept.
                      
                      OUTPUT FORMAT (STRICT):
                      Title: <New Title>
                      Category: <Feature | Improvement | Security | Internal>
                      User Facing: <true | false>
                      Summary: <Summary Text>
                      """
                  
                  response = model.generate_content(prompt)
                  if response.text:
                      # Parse Response
                      lines = response.text.strip().split('\n')
                      current_key = None
                      for line in lines:
                          if line.startswith("Title:"):
                              final_title = line.replace("Title:", "").strip()
                          elif line.startswith("Category:"):
                              category = line.replace("Category:", "").strip()
                          elif line.startswith("User Facing:"):
                              user_facing = line.replace("User Facing:", "").strip().lower()
                          elif line.startswith("Summary:"):
                              final_summary = line.replace("Summary:", "").strip()
                              current_key = "Summary"
                          elif current_key == "Summary" and not any(line.startswith(k) for k in ["Title:", "Category:", "User Facing:"]):
                              final_summary += " " + line.strip()
                              
                      print("Gemini generated content successfully.")
              except Exception as e:
                  print(f"Gemini generation failed: {e}")

          # 5. Write Content (Preserving/Updating Frontmatter)
          
          # Format Date for Display (Use most recent deployment time)
          display_date = datetime.strptime(deploy_time[:8], "%Y%m%d").strftime("%b %d, %Y")

          # Construct YAML Frontmatter manually to ensure order/cleanliness
          # using pyyaml dump for the deployments list
          deployments_yaml = yaml.dump(deployments, default_flow_style=False).strip()
          
          content = dedent(
              f"""\
              ---
              issue_id: {issue_id}
              latest_deploy: {deploy_time}
              category: {category}
              user_facing: {user_facing}
              deployments:
              {dedent(deployments_yaml).replace('^', '  ')}
              ---

              # {final_title}

              **Date:** {display_date}  
              **Category:** {category}

              {final_summary}

              _More details or escalation info here as appropriate._
              """
          )
          
          # Write to file
          os.makedirs("releases", exist_ok=True)
          with open(fname, "w", encoding="utf-8") as f:
              f.write(content)
              
          print(f"Created/Updated release file: {fname}")
          PY

          echo "fname=$fname" >> "$GITHUB_OUTPUT"
          echo "target_branch=$target_branch" >> "$GITHUB_OUTPUT"

      - name: Debug payload and workspace
        run: |
          set -euo pipefail
          target_branch="${{ steps.parse.outputs.target_branch }}"
          echo "Event path: $GITHUB_EVENT_PATH"
          echo "Workspace contents:"
          ls -la
          echo "Releases dir:"
          ls -la releases || true
          echo "Target branch: $target_branch"

      - name: Regenerate index
        run: |
          set -euo pipefail
          echo "# EHS Dashboard â€” Release Notes" > index.md
          echo "" >> index.md
          echo "This page is auto-generated by CI. See \`releases/\` for individual release notes." >> index.md
          echo "" >> index.md
          echo "## Latest Updates" >> index.md
          echo "" >> index.md
          
          # Loop through files, sorted by name (descending date)
          for f in $(ls -1 releases/*.md 2>/dev/null | sort -r); do
            basename=$(basename "$f")
            
            # Extract metadata using simple grep/sed
            # Date is in filename: YYYYMMDD...
            raw_date=$(echo "$basename" | cut -d'_' -f1 | cut -c1-8)
            formatted_date=$(date -d "$raw_date" "+%b %d, %Y" 2>/dev/null || echo "$raw_date")
            
            # Extract Title (Line starting with # )
            title_line=$(grep -m1 "^# " "$f" | sed 's/^# //')
            [ -z "$title_line" ] && title_line="Release $raw_date"
            
            # Extract Category from frontmatter
            category=$(grep -m1 "^category: " "$f" | sed 's/^category: //' || echo "")
            [ -z "$category" ] && category="Update"
            
            # Extract User Facing from frontmatter
            user_facing=$(grep -m1 "^user_facing: " "$f" | sed 's/^user_facing: //' || echo "true")
            
            # Choose Emoji
            icon="ðŸ“¦"
            case "$category" in
              Feature) icon="ðŸš€" ;;
              Fix) icon="ðŸ›" ;;
              Improvement) icon="âœ¨" ;;
              Security) icon="ðŸ”’" ;;
              Internal) icon="ðŸ› ï¸" ;;
            esac
            
            # Filter Logic: If user_facing is strictly "false", maybe skip? 
            # For now, let's just label it "Internal" or show all for transparency.
            if [[ "$user_facing" == "false" ]]; then continue; fi

            echo "- **$formatted_date** â€” $icon **$category**: [$title_line]($f)" >> index.md
          done || true

      - name: Build releases JSON
        run: |
          set -euo pipefail
          python3 scripts/build_releases_json.py

      - name: Commit and push
        run: |
          set -euo pipefail
          git config user.name "Release Bot"
          git config user.email "ci@higherelevationsoftware.com"
          git add -A
          git commit -m "Add release note: ${{ steps.parse.outputs.fname }}" || exit 0
          git push origin HEAD:${{ steps.parse.outputs.target_branch }}
