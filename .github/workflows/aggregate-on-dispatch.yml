name: Aggregate release note (on repository_dispatch)

on:
  repository_dispatch:
    types: [release-note]

env:
  TARGET_BRANCH: ${{ github.event.repository.default_branch }}
  TARGET_BRANCH_OVERRIDE: ${{ github.event.client_payload.target_branch }}

permissions:
  contents: write

jobs:
  add-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Validate, Parse, and Enhance with Gemini
        id: parse
        env:
          GH_TOKEN: ${{ secrets.REPO_READER_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -euo pipefail
          export GH_TOKEN="${{ secrets.REPO_READER_TOKEN }}"
          
          # Install dependencies
          pip install google-generativeai requests

          event="$GITHUB_EVENT_PATH"
          component=$(jq -r '.client_payload.component // ""' "$event")
          sha=$(jq -r '.client_payload.sha // ""' "$event")
          title=$(jq -r '.client_payload.title // ""' "$event")
          summary=$(jq -r '.client_payload.summary // ""' "$event")
          pr=$(jq -r '.client_payload.pr // ""' "$event")
          deploy_time=$(jq -r '.client_payload.deploy_time // ""' "$event")
          environment=$(jq -r '.client_payload.environment // ""' "$event")
          target_branch=$(jq -r '.client_payload.target_branch // ""' "$event")

          if [ -z "$component" ] || [ -z "$sha" ] || [ -z "$title" ]; then
            echo "Missing required fields: component, sha, and title are required" >&2
            exit 1
          fi

          # Defaults
          [ -z "$summary" ] && summary="$title"
          [ -z "$deploy_time" ] && deploy_time=$(date -u +%Y%m%dT%H%M%SZ)
          [ -z "$environment" ] && environment="production"
          [ -z "$target_branch" ] && target_branch="${TARGET_BRANCH_OVERRIDE:-}"
          [ -z "$target_branch" ] && target_branch="$TARGET_BRANCH"

          # Fetch PR Context
          repo_name="Higher-Elevation-Software/$component"
          pr_title=""
          pr_body=""

          echo "Attempting to fetch PR details for $repo_name..."
          if [ -n "$pr" ] && [ "$pr" != "null" ]; then
             echo "Fetching PR #$pr..."
             # Fetch PR JSON or return ERROR on failure
             json=$(gh pr view "$pr" -R "$repo_name" --json title,body 2>&1 || echo "ERROR")
             
             # Check if gh command succeeded
             if [[ "$json" == "ERROR" ]] || [[ "$json" == *"graphql error"* ]] || [[ "$json" == *"Could not resolve to a PullRequest"* ]]; then
                echo "Failed to fetch PR #$pr via gh CLI."
                echo "Error output: $json"
             else
                # Parse JSON safely
                pr_title=$(echo "$json" | jq -r .title 2>/dev/null || echo "")
                pr_body=$(echo "$json" | jq -r .body 2>/dev/null || echo "")
                
                if [ -n "$pr_title" ]; then
                    echo "Found PR #$pr details."
                else
                    echo "Failed to parse JSON for PR #$pr."
                    echo "Raw output: $json"
                fi
             fi
          elif [ -n "$sha" ]; then
             echo "Searching for PR associated with SHA $sha..."
             # Try to find PR by SHA
             json=$(gh pr list -R "$repo_name" --search "$sha" --state merged --json number,title,body --limit 1 2>&1 | jq '.[0] // empty' || echo "ERROR")
              if [[ "$json" != "ERROR" ]] && [ -n "$json" ]; then
                pr_title=$(echo "$json" | jq -r .title)
                pr_body=$(echo "$json" | jq -r .body)
                pr=$(echo "$json" | jq -r .number)
                echo "Found PR #$pr via SHA."
             else
                echo "No PR found for SHA $sha or error occurred."
                if [[ "$json" == "ERROR" ]]; then echo "Error details: $(gh pr list -R "$repo_name" --search "$sha" --state merged --json number,title,body --limit 1 2>&1)"; fi
             fi
          fi

          short_sha=${sha:0:7}
          safe_component=$(echo "$component" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]-' '-')
          fname="releases/${deploy_time}_${safe_component}_${short_sha}.md"

          mkdir -p releases

          # Export variables for Python
          export component
          export sha
          export title
          export summary
          export pr
          export deploy_time
          export environment
          export target_branch
          export fname
          export pr_title
          export pr_body

          python3 - <<'PY'
          import os
          import google.generativeai as genai
          from textwrap import dedent

          component = os.environ["component"]
          sha = os.environ["sha"]
          title = os.environ["title"]
          summary = os.environ["summary"]
          pr = os.environ["pr"]
          deploy_time = os.environ["deploy_time"]
          environment = os.environ["environment"]
          fname = os.environ["fname"]
          
          pr_title = os.environ.get("pr_title", "")
          pr_body = os.environ.get("pr_body", "")
          gemini_api_key = os.environ.get("GEMINI_API_KEY", "")

          final_summary = summary
          final_title = title
          category = "Update"
          user_facing = "true"
          
          # Format date for display (YYYY-MM-DD)
          display_date = deploy_time[:8]
          display_date = f"{display_date[:4]}-{display_date[4:6]}-{display_date[6:]}"
          
          # AI Enhancement Logic
          if gemini_api_key and (pr_title or pr_body):
              try:
                  genai.configure(api_key=gemini_api_key)
                  model = genai.GenerativeModel('gemini-2.5-flash-lite')
                  
                  prompt = f"""
                  You are writing release notes for a public changelog. 
                  The audience is end-users, so be concise, user-friendly, and avoid purely technical jargon if possible.
                  
                  Inputs:
                  - Component: {component}
                  - Commit Message: {title}
                  - Commit Details: {summary}
                  - PR Title: {pr_title}
                  - PR Description: {pr_body}
                  
                  Instructions:
                  1. Look for a section named "Release Notes" in the PR Description. If it exists, prioritize that content.
                  2. Generate a concise, user-friendly Title (5-8 words). Focus on the *benefit*.
                  3. Summarize the changes in 1-2 sentences.
                  4. **TONE & BRAND GUIDELINES (CRITICAL):**
                     - Tone: Professional, Reassuring, Authoritative.
                     - **Do NOT** imply that the previous version was "broken", "wrong", or "inaccurate" unless explicitly stated as a critical security incident.
                     - **Avoid negative words:** "fix", "error", "bug", "incorrect", "issue", "problem", "failure".
                     - **Use positive framing:** Instead of "Fixed calculation error", say "Refined calculation logic for greater consistency." instead of "Fixed crash", say "Improved application stability."
                     - Focus on the *value* provided (e.g., "Improved consistency," "Enhanced handling of X," "Streamlined Y").
                  5. Determine the Category: "Feature", "Fix", "Improvement", "Security", or "Internal".
                  6. Determine if User Facing: "true" or "false".
                  7. Output format:
                  Title: <New Title>
                  Category: <Category>
                  User Facing: <true/false>
                  Summary: <Summary Text>
                  """
                  
                  response = model.generate_content(prompt)
                  if response.text:
                      # Simple parsing of the response
                      lines = response.text.strip().split('\n')
                      for line in lines:
                          if line.startswith("Title:"):
                              final_title = line.replace("Title:", "").strip()
                          elif line.startswith("Category:"):
                              category = line.replace("Category:", "").strip()
                          elif line.startswith("User Facing:"):
                              user_facing = line.replace("User Facing:", "").strip().lower()
                          elif line.startswith("Summary:"):
                              final_summary = line.replace("Summary:", "").strip()
                          elif not line.startswith("Category:") and not line.startswith("User Facing:") and not line.startswith("Summary:") and not line.startswith("Title:"):
                              # Append continuation lines to summary if they exist
                              if final_summary == summary:
                                  final_summary = line.strip()
                              else:
                                  final_summary += " " + line.strip()
                                  
                      print("Gemini generated content successfully.")
              except Exception as e:
                  print(f"Gemini generation failed: {e}")
                  # Fallback to original summary is already set

          content = dedent(
              f"""\
              ---
              component: {component}
              sha: {sha}
              deploy_time: {deploy_time}
              pr: {pr}
              environment: {environment}
              category: {category}
              user_facing: {user_facing}
              ---

              # {final_title}

              **Component:** {component}  
              **Date:** {display_date}  
              **Environment:** {environment}

              {final_summary}

              _More details or escalation info here as appropriate._
              """
          )

          with open(fname, "w", encoding="utf-8") as f:
              f.write(content)
              
          print(f"Created release file: {fname}")
          PY

          echo "fname=$fname" >> "$GITHUB_OUTPUT"
          echo "target_branch=$target_branch" >> "$GITHUB_OUTPUT"

      - name: Debug payload and workspace
        run: |
          set -euo pipefail
          target_branch="${{ steps.parse.outputs.target_branch }}"
          echo "Event path: $GITHUB_EVENT_PATH"
          echo "Workspace contents:"
          ls -la
          echo "Releases dir:"
          ls -la releases || true
          echo "Target branch: $target_branch"

      - name: Regenerate index
        run: |
          set -euo pipefail
          echo "# EHS Dashboard â€” Release Notes" > index.md
          echo "" >> index.md
          echo "This page is auto-generated by CI. See \`releases/\` for individual release notes." >> index.md
          echo "" >> index.md
          echo "## Latest Updates" >> index.md
          echo "" >> index.md
          
          # Loop through files, sorted by name (descending date)
          for f in $(ls -1 releases/*.md 2>/dev/null | sort -r); do
            basename=$(basename "$f")
            
            # Extract metadata using simple grep/sed
            # Date is in filename: YYYYMMDD...
            raw_date=$(echo "$basename" | cut -d'_' -f1 | cut -c1-8)
            formatted_date=$(date -d "$raw_date" "+%b %d, %Y" 2>/dev/null || echo "$raw_date")
            
            # Extract Title (Line starting with # )
            title_line=$(grep -m1 "^# " "$f" | sed 's/^# //')
            [ -z "$title_line" ] && title_line="Release $raw_date"
            
            # Extract Category from frontmatter
            category=$(grep -m1 "^category: " "$f" | sed 's/^category: //' || echo "")
            [ -z "$category" ] && category="Update"
            
            # Extract User Facing from frontmatter
            user_facing=$(grep -m1 "^user_facing: " "$f" | sed 's/^user_facing: //' || echo "true")
            
            # Choose Emoji
            icon="ðŸ“¦"
            case "$category" in
              Feature) icon="ðŸš€" ;;
              Fix) icon="ðŸ›" ;;
              Improvement) icon="âœ¨" ;;
              Security) icon="ðŸ”’" ;;
              Internal) icon="ðŸ› ï¸" ;;
            esac
            
            # Filter Logic: If user_facing is strictly "false", maybe skip? 
            # For now, let's just label it "Internal" or show all for transparency.
            if [[ "$user_facing" == "false" ]]; then continue; fi

            echo "- **$formatted_date** â€” $icon **$category**: [$title_line]($f)" >> index.md
          done || true

      - name: Commit and push
        run: |
          set -euo pipefail
          git config user.name "Release Bot"
          git config user.email "ci@higherelevationsoftware.com"
          git add -A
          git commit -m "Add release note: ${{ steps.parse.outputs.fname }}" || exit 0
          git push origin HEAD:${{ steps.parse.outputs.target_branch }}
