name: Aggregate release note (on repository_dispatch)

on:
  repository_dispatch:
    types: [release-note]

env:
  TARGET_BRANCH: ${{ github.event.repository.default_branch }}
  TARGET_BRANCH_OVERRIDE: ${{ github.event.client_payload.target_branch }}

permissions:
  contents: write

jobs:
  add-release:
    runs-on: ubuntu-latest
    concurrency:
      group: aggregate-release-note-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Validate, Parse, and Enhance with Gemini
        id: parse
        env:
          GH_TOKEN: ${{ secrets.REPO_READER_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -euo pipefail
          export GH_TOKEN="${{ secrets.REPO_READER_TOKEN }}"
          
          # Install dependencies
          pip install google-generativeai requests pyyaml

          event="$GITHUB_EVENT_PATH"
          component=$(jq -r '.client_payload.component // ""' "$event")
          sha=$(jq -r '.client_payload.sha // ""' "$event")
          title=$(jq -r '.client_payload.title // ""' "$event")
          summary=$(jq -r '.client_payload.summary // ""' "$event")
          pr=$(jq -r '.client_payload.pr // ""' "$event")
          deploy_time=$(jq -r '.client_payload.deploy_time // ""' "$event")
          environment=$(jq -r '.client_payload.environment // ""' "$event")
          target_branch=$(jq -r '.client_payload.target_branch // ""' "$event")

          if [ -z "$component" ] || [ -z "$sha" ] || [ -z "$title" ]; then
            echo "Missing required fields: component, sha, and title are required" >&2
            exit 1
          fi

          # Defaults
          [ -z "$summary" ] && summary="$title"
          [ -z "$deploy_time" ] && deploy_time=$(date -u +%Y%m%dT%H%M%SZ)
          [ -z "$environment" ] && environment="production"
          [ -z "$target_branch" ] && target_branch="${TARGET_BRANCH_OVERRIDE:-}"
          [ -z "$target_branch" ] && target_branch="$TARGET_BRANCH"

          # Fetch PR Context
          repo_name="Higher-Elevation-Software/$component"
          pr_title=""
          pr_body=""

          echo "Attempting to fetch PR details for $repo_name..."
          if [ -n "$pr" ] && [ "$pr" != "null" ]; then
             echo "Fetching PR #$pr..."
             # Fetch PR JSON or return ERROR on failure
             json=$(gh pr view "$pr" -R "$repo_name" --json title,body 2>&1 || echo "ERROR")
             
             # Check if gh command succeeded
             if [[ "$json" == "ERROR" ]] || [[ "$json" == *"graphql error"* ]] || [[ "$json" == *"Could not resolve to a PullRequest"* ]]; then
                echo "Failed to fetch PR #$pr via gh CLI."
                echo "Error output: $json"
             else
                # Parse JSON safely
                pr_title=$(echo "$json" | jq -r .title 2>/dev/null || echo "")
                pr_body=$(echo "$json" | jq -r .body 2>/dev/null || echo "")
                
                if [ -n "$pr_title" ]; then
                    echo "Found PR #$pr details."
                else
                    echo "Failed to parse JSON for PR #$pr."
                    echo "Raw output: $json"
                fi
             fi
          elif [ -n "$sha" ]; then
             echo "Searching for PR associated with SHA $sha..."
             # Try to find PR by SHA
             json=$(gh pr list -R "$repo_name" --search "$sha" --state merged --json number,title,body --limit 1 2>&1 | jq '.[0] // empty' || echo "ERROR")
              if [[ "$json" != "ERROR" ]] && [ -n "$json" ]; then
                pr_title=$(echo "$json" | jq -r .title)
                pr_body=$(echo "$json" | jq -r .body)
                pr=$(echo "$json" | jq -r .number)
                echo "Found PR #$pr via SHA."
             else
                echo "No PR found for SHA $sha or error occurred."
                if [[ "$json" == "ERROR" ]]; then echo "Error details: $(gh pr list -R "$repo_name" --search "$sha" --state merged --json number,title,body --limit 1 2>&1)"; fi
             fi
          fi

          short_sha=${sha:0:7}
          safe_component=$(echo "$component" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]-' '-')
          fname="releases/${deploy_time}_${safe_component}_${short_sha}.md"

          mkdir -p releases

          # Export variables for Python
          export component
          export sha
          export title
          export summary
          export pr
          export deploy_time
          export environment
          export target_branch
          export fname
          export pr_title
          export pr_body

          python3 - <<'PY'
          import os
          import re
          import yaml
          import google.generativeai as genai
          from textwrap import dedent
          from datetime import datetime

          INSTRUCTIONS_TEXT = """
          Audience: EHS administrators and compliance stakeholders reading a changelog, not a marketing campaign.

          1. Write a short, factual Title (5â€“9 words) that describes what changed, not how it was implemented.
          2. Summarize the change in at most 2â€“3 sentences and no more than about 70 words total.
          3. Emphasize what users can now see or do (for example, new pages, metrics, or clearer reporting) and how it improves reliability, clarity, or workflow.
          4. TONE: Neutral, professional, and calm. Do not use phrases like "we're excited", "powerful", "robust", "unparalleled", or similarly promotional language.
          5. Do not mention past failures or defects. Avoid words like "fix", "bug", "wrong", "issue", or "broken".
          6. ABSTRACTION: Do NOT mention file paths, classes, helper methods, or variable names (for example: `chem_record`, `constsum`). Describe only the visible behavior and business value.
          7. It is acceptable to mention backend calculations or emissions logic at a high level (for example, "more consistent chemical amounts" or "clearer emissions totals"), but keep the description non-technical.
          """

          component = os.environ["component"]
          sha = os.environ["sha"]
          title = os.environ["title"]
          summary = os.environ["summary"]
          pr = os.environ["pr"]
          deploy_time = os.environ["deploy_time"]
          environment = os.environ["environment"]
          
          pr_title = os.environ.get("pr_title", "")
          pr_body = os.environ.get("pr_body", "")
          gemini_api_key = os.environ.get("GEMINI_API_KEY", "")

          # 1. Extract Issue ID (HES-XXX)
          issue_id = ""
          hes_match = re.search(r"(hes-\d+)", title + " " + pr_title + " " + pr_body, re.IGNORECASE)
          if hes_match:
              issue_id = hes_match.group(1).upper()

          # 2. Determine File Path & Mode
          # If we have an Issue ID, we look for a Feature File. Otherwise, generic timestamp file.
          is_feature_mode = bool(issue_id)
          
          if is_feature_mode:
              fname = f"releases/ISSUE_{issue_id}.md"
          else:
              short_sha = sha[:7]
              safe_component = re.sub(r'[^a-zA-Z0-9-]', '-', component.lower())
              fname = f"releases/{deploy_time}_{safe_component}_{short_sha}.md"
          
          # Export fname for later steps
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"fname={fname}\n")

          # 3. Load Existing Data (If updating)
          existing_content = ""
          existing_frontmatter = {}
          deployments = []
          
          if os.path.exists(fname):
              print(f"Found existing release note for {issue_id}. Merging...")
              with open(fname, 'r') as f:
                  raw_content = f.read().strip()
                  
              # Split YAML Frontmatter
              if raw_content.startswith("---"):
                  try:
                      parts = raw_content.split("---", 2)
                      if len(parts) >= 3:
                          fm_text = parts[1]
                          existing_frontmatter = yaml.safe_load(fm_text) or {}
                          existing_content = parts[2].strip()
                          deployments = existing_frontmatter.get('deployments', [])
                          print(f"Loaded {len(deployments)} existing deployments.")
                  except Exception as e:
                      print(f"Error parsing existing frontmatter: {e}")
          
          # Add current deployment to list
          # Check if this SHA already exists to prevent duplicates
          if not any(d.get('sha') == sha and d.get('component') == component for d in deployments):
              current_deployment = {
                  'component': component,
                  'sha': sha,
                  'deploy_time': deploy_time,
                  'pr': pr,
                  'environment': environment
              }
              deployments.append(current_deployment)
              print(f"Appended new deployment. Total: {len(deployments)}")
          else:
              print("Deployment with this SHA already exists in list.")

          # 4. Prepare Gemini Inputs
          final_summary = summary
          final_title = title
          category = "Update"
          user_facing = "true"
          
          # Determine Prompt Type (Create vs Merge)
          if gemini_api_key and (pr_title or pr_body):
              try:
                  genai.configure(api_key=gemini_api_key)
                  model = genai.GenerativeModel('gemini-2.5-flash')
                  
                  if existing_content:
                      # MERGE PROMPT
                      prompt = f"""
                      You are an expert Product Marketing Manager for a high-trust EHS Compliance platform.
                      
                      TASK: Update an existing release note to include a new component deployment.
                      The goal is to have a SINGLE cohesive story for the feature "{issue_id}", covering all affected components.
                      
                      EXISTING NOTE:
                      {existing_content}
                      
                      NEW UPDATE ({component}):
                      PR Title: {pr_title}
                      PR Description: {pr_body}
                      
                      INSTRUCTIONS:
                      {INSTRUCTIONS_TEXT}
                      
                      OUTPUT FORMAT (STRICT):
                      Title: <Merged Title>
                      Category: <Category>
                      User Facing: <true/false>
                      Summary: <Merged Summary>
                      """
                  else:
                      # CREATE PROMPT (Standard)
                      prompt = f"""
                      You are an expert Product Marketing Manager for a high-trust Enterprise EHS Compliance platform.
                      
                      TASK: Transform technical inputs into a customer-facing release note.
                      
                      Inputs:
                      - Component: {component}
                      - PR Title: {pr_title}
                      - PR Description: {pr_body}
                      
                      INSTRUCTIONS:
                      {INSTRUCTIONS_TEXT}
                      
                      OUTPUT FORMAT (STRICT):
                      Title: <New Title>
                      Category: <Feature | Improvement | Security | Internal>
                      User Facing: <true | false>
                      Summary: <Summary Text>
                      """
                  
                  response = model.generate_content(prompt)
                  if response.text:
                      # Parse Response
                      lines = response.text.strip().split('\n')
                      current_key = None
                      for line in lines:
                          if line.startswith("Title:"):
                              final_title = line.replace("Title:", "").strip()
                          elif line.startswith("Category:"):
                              category = line.replace("Category:", "").strip()
                          elif line.startswith("User Facing:"):
                              user_facing = line.replace("User Facing:", "").strip().lower()
                          elif line.startswith("Summary:"):
                              final_summary = line.replace("Summary:", "").strip()
                              current_key = "Summary"
                          elif current_key == "Summary" and not any(line.startswith(k) for k in ["Title:", "Category:", "User Facing:"]):
                              final_summary += " " + line.strip()
                              
                      print("Gemini generated content successfully.")
              except Exception as e:
                  print(f"Gemini generation failed: {e}")

          # 5. Write Content (Preserving/Updating Frontmatter)
          
          # Format Date for Display (Use most recent deployment time)
          display_date = datetime.strptime(deploy_time[:8], "%Y%m%d").strftime("%b %d, %Y")

          # Construct Full Frontmatter Dictionary
          # Derive unique list of components from deployments, preserving order.
          components = []
          seen_components = set()
          for d in deployments:
              c = d.get('component')
              if c and c not in seen_components:
                  seen_components.add(c)
                  components.append(c)

          frontmatter_data = {
              'issue_id': issue_id,
              'latest_deploy': deploy_time,
              'category': category,
              'user_facing': user_facing,
              # New fields to make component data explicit for consumers
              'components': components,
              'component': ", ".join(components) if components else 'unknown',
              'deployments': deployments,
          }
          
          # Dump Frontmatter to string
          frontmatter_str = yaml.dump(frontmatter_data, default_flow_style=False, sort_keys=False).strip()
          
          content = (
              f"---\n"
              f"{frontmatter_str}\n"
              f"---\n\n"
              f"# {final_title}\n\n"
              f"**Date:** {display_date}  \n"
              f"**Category:** {category}\n\n"
              f"{final_summary}\n\n"
              f"_More details or escalation info here as appropriate._\n"
          )
          
          # Write to file
          os.makedirs("releases", exist_ok=True)
          with open(fname, "w", encoding="utf-8") as f:
              f.write(content)
              
          print(f"Created/Updated release file: {fname}")
          PY

          echo "fname=$fname" >> "$GITHUB_OUTPUT"
          echo "target_branch=$target_branch" >> "$GITHUB_OUTPUT"

      - name: Debug payload and workspace
        run: |
          set -euo pipefail
          target_branch="${{ steps.parse.outputs.target_branch }}"
          echo "Event path: $GITHUB_EVENT_PATH"
          echo "Workspace contents:"
          ls -la
          echo "Releases dir:"
          ls -la releases || true
          echo "Target branch: $target_branch"

      - name: Regenerate index
        run: |
          set -euo pipefail
          echo "# EHS Dashboard â€” Release Notes" > index.md
          echo "" >> index.md
          echo "This page is auto-generated by CI. See \`releases/\` for individual release notes." >> index.md
          echo "" >> index.md
          echo "## Latest Updates" >> index.md
          echo "" >> index.md
          
          # Loop through files, sorted by name (descending date)
          for f in $(ls -1 releases/*.md 2>/dev/null | sort -r); do
            basename=$(basename "$f")
            
            # Extract metadata using simple grep/sed
            # Date is in filename: YYYYMMDD...
            raw_date=$(echo "$basename" | cut -d'_' -f1 | cut -c1-8)
            formatted_date=$(date -d "$raw_date" "+%b %d, %Y" 2>/dev/null || echo "$raw_date")
            
            # Extract Title (Line starting with # )
            title_line=$(grep -m1 "^# " "$f" | sed 's/^# //')
            [ -z "$title_line" ] && title_line="Release $raw_date"
            
            # Extract Category from frontmatter
            category=$(grep -m1 "^category: " "$f" | sed 's/^category: //' || echo "")
            [ -z "$category" ] && category="Update"
            
            # Extract User Facing from frontmatter
            user_facing=$(grep -m1 "^user_facing: " "$f" | sed 's/^user_facing: //' || echo "true")
            
            # Choose Emoji
            icon="ðŸ“¦"
            case "$category" in
              Feature) icon="ðŸš€" ;;
              Fix) icon="ðŸ›" ;;
              Improvement) icon="âœ¨" ;;
              Security) icon="ðŸ”’" ;;
              Internal) icon="ðŸ› ï¸" ;;
            esac
            
            # Filter Logic: If user_facing is strictly "false", maybe skip? 
            # For now, let's just label it "Internal" or show all for transparency.
            if [[ "$user_facing" == "false" ]]; then continue; fi

            echo "- **$formatted_date** â€” $icon **$category**: [$title_line]($f)" >> index.md
          done || true

      - name: Build releases JSON
        run: |
          set -euo pipefail
          python3 scripts/build_releases_json.py

      - name: Commit and push (PR branch)
        env:
          GITHUB_TOKEN: ${{ secrets.AGGREGATOR_TOKEN }}
         run: |
          set -euo pipefail

          git config user.name "Release Bot"
          git config user.email "ci@higherelevationsoftware.com"

          git add -A
          # If there are no changes, exit early
          git diff --cached --quiet && echo "No changes to commit" && exit 0

          note_path="${{ steps.parse.outputs.fname }}"
          note_slug="$(basename "$note_path" .md)"
          timestamp="$(date -u +%Y%m%dT%H%M%SZ)"
          branch="release-notes/${note_slug}-${timestamp}"

          git commit -m "Add release note: $note_path"
          git push origin HEAD:"$branch"

          # Create or update a pull request for this branch targeting the desired base branch.
          api_url="https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls"
          title="Release notes: ${note_slug}"
          body="Automated release-note update for ${note_slug}. Generated by CI from repository_dispatch."

          payload=$(jq -n --arg head "$branch" --arg base "${{ steps.parse.outputs.target_branch }}" --arg title "$title" --arg body "$body" '{head:$head, base:$base, title:$title, body:$body}')

          echo "Creating pull request from $branch to ${{ steps.parse.outputs.target_branch }}" 
          curl -sS -X POST \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "$api_url" \
            -d "$payload" \
            | jq '.number // .message' || true
